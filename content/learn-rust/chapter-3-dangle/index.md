+++
title = "低レイヤに入門して学ぶRustの安全性"
date = "2022-02-06T22:28:05+09:00"
draft = false
+++

# 低レイヤに入門して学ぶRustの安全性

この章では、ダングリングポインタがなぜ危険なのか、そしてRustのライフタイムを学び、Rustの安全性が意味することについて考えます。

[TRPLのライフタイムで参照を検証する](https://doc.rust-jp.rs/book-ja/ch10-03-lifetime-syntax.html) の章で、以下のようなコードが記載されています。

```rust
{
    let r;

    {
        let x = 5;
        r = &x;
    }

    println!("r: {}", r);
}
```

このコードはコンパイルできません。なぜなら、`x`のライフタイムは宣言された `let x = 5;` から始まり、スコープを抜けるまでの間なので、`r`、つまり`x`の参照がスコープ外で無効だからです。

なぜライフタイムを通じてスコープ外の変数を参照することを禁じているのでしょうか？この詳細をC言語や低レイヤの観点から理解できるようになることが本資料の目的です。

それではまずはC言語で同等の動作をするコードを見ていきましょう。

# C言語でダングリングポインタを作る

まずはダングリングポインタがやばい例を紹介し、その次に解説をしていきます。

それでは、以下のコードをコンパイルして実行してみましょう！

```c
// test1.c
#include <stdio.h>

char *f()
{
  char *r;
  char x;
  scanf("%c", &x);
  r = &x;
  printf("&r in f(): %p\n", r);
  return r;
}

// corrupt stack memory
void corrupt()
{
  char d3[100];
  for (int i = 0; i < 100; i++)
  {
    d3[i] = 'z';
  }
}

int main()
{
  printf("Input char!: ");
  char *r = f();

  corrupt();

  printf("Your char: %c\n", *r);
  printf("&r in main(): %p\n", r);
}

```

コンパイルは以下のコマンドです。x86_64環境で動作を確認しています。

```bash
# 環境
# Linux 5.4.0-100-generic #113-Ubuntu SMP Thu Feb 3 18:43:29 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux
gcc test1.c
```

`a.out`というファイルが生成されていると思います。実行してみましょう。

```bash
$ ./a.out
Input char!: 
```

何か文字を入力してくださいと言われているので一文字入力します。すると以下のように表示されます。

```bash
$ ./a.out 
Input char!: a
&r in f(): 0x7ffceed4de8f
Your char: z
&r in main(): 0x7ffceed4de8f
```

入力した文字は `a` なのに、 `z` ですね！と言われてしまいました。他の文字を入力しても `z` になってしまうことが確認できると思います。
これはおかしいのでプログラムが実際どのように動いているか読んでいきましょう。

# Cのコードを読む

`f()` と `corrupt()` と `main()` の3つ関数があることがわかるので、まず `main()`から動作を追っていきましょう。

```c
int main()
{
  printf("Input char!: ");
  char *r = f();

  corrupt();

  printf("Your char: %c\n", *r);
  printf("&r in main(): %p\n", r);
}
```

`main()` の動作は、char型のポインタ `r` を`f()`から受け取り、`corrupt()`関数を実行して `r`のdereferenceした値、すなわちcharを出力して `r` 自体の値、すなわちアドレス値を返して終了しています。

ここでポイントなのは、`corrupt()`関数は変数`r`に影響を及ぼしていないように見えるため、`f()`の返り値をそのまま出力しているはずだ、というところです。

実際に `corrupt()` 関数を読んでみると、

```c
// corrupt stack memory
void corrupt()
{
  char d3[100];
  for (int i = 0; i < 100; i++)
  {
    d3[i] = 'z';
  }
}
```

内部で`d3`という配列を生成し代入しているだけなので、`r`に影響はないように見えます。

それでは問題の `f()` を読んでいきます。

```c
char *f()
{
  char *r;
  char x;
  scanf("%c", &x);
  r = &x;
  printf("&r in f(): %p\n", r);
  return r;
}
```

char型のポインタを返しています。
内部では、scanfを用いて変数 `x` へと入力した値を代入し、そのアドレス値をrに渡して`r`を返却しています。

今一度、冒頭のTRPLのコードを見てみましょう

```rust
{
    let r;

    {
        let x = 5;
        r = &x;
    }

    println!("r: {}", r);
}
```

これも変数`x`のreferenceを`r`に入れています。スコープを抜ける値 `x` に対する参照を、そのスコープ外でも生きるようにしているという点で `f()` とTRPLのコードは同じことをしていると言えます。

CではRustのようにコンパイルで止められることはありません。

以上をまとめると、`f()`で入力された値の参照(アドレス値)を`r`として`main()`で取得し、`main()`で入力された値のアドレスが指し示す先、すなわち入力した値を出力する。となります。

しかし実際の動作は何を入力しても `z` が帰ってくるだけでした。なぜこのような挙動をするのでしょうか？その理由を解説します。

# 無効な参照とスタックの様子
